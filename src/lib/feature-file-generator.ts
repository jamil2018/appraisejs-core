import { promises as fs } from 'fs'
import { join } from 'path'
import prisma from '@/config/db-config'
import { buildModulePath } from '@/lib/path-helpers/module-path'

/**
 * Generates a Gherkin feature file for a test suite
 * @param testSuiteId - The ID of the test suite
 * @param testSuiteName - The name of the test suite
 * @param testSuiteDescription - The description of the test suite
 * @param moduleName - The name of the module the test suite belongs to
 * @returns Promise<string> - The path to the generated feature file
 */
export async function generateFeatureFile(
  testSuiteId: string,
  testSuiteName: string,
  testSuiteDescription?: string,
): Promise<string> {
  try {
    // Fetch test suite with test cases, steps, and all modules for path building
    const [testSuite, allModules] = await Promise.all([
      prisma.testSuite.findUnique({
        where: { id: testSuiteId },
        include: {
          testCases: {
            include: {
              steps: {
                include: {
                  parameters: true,
                },
                orderBy: {
                  order: 'asc',
                },
              },
            },
          },
          module: true,
        },
      }),
      prisma.module.findMany(), // Get all modules to build hierarchy path
    ])

    if (!testSuite) {
      throw new Error(`Test suite with ID ${testSuiteId} not found`)
    }

    // Build the module path for directory structure
    const modulePath = buildModulePath(allModules, testSuite.module)

    // Generate feature file content
    const featureContent = generateFeatureContent(
      testSuiteDescription || testSuiteName, // Use description as feature title, fallback to name
      testSuite.testCases,
    )

    // Create the features directory with module path
    const featuresBaseDir = join(process.cwd(), 'src', 'tests', 'features')
    const moduleDir = join(featuresBaseDir, modulePath.substring(1)) // Remove leading slash
    await fs.mkdir(moduleDir, { recursive: true })

    // Generate a safe filename from the test suite name only
    const safeFileName = generateSafeFileName(testSuiteName)
    const featureFilePath = join(moduleDir, `${safeFileName}.feature`)

    // Write the feature file
    await fs.writeFile(featureFilePath, featureContent, 'utf8')

    return featureFilePath
  } catch (error) {
    console.error('Error generating feature file:', error)
    throw error
  }
}

/**
 * Generates the content for a Gherkin feature file
 */
function generateFeatureContent(
  featureTitle: string,
  testCases: Array<{
    title: string
    description: string
    steps: Array<{
      gherkinStep: string
      order: number
    }>
  }>,
): string {
  const lines: string[] = []

  // Warning header
  lines.push('# AUTO-GENERATED FILE - DO NOT EDIT MANUALLY')
  lines.push('# This file is automatically generated from Test Suite data.')
  lines.push('# Any manual changes will be overwritten when the Test Suite is updated.')
  lines.push('# To modify this feature, update the corresponding Test Suite in the application.')
  lines.push('')

  // Feature header - use description as feature title
  lines.push(`Feature: ${featureTitle}`)
  lines.push('')

  // Generate scenarios for each test case that has steps
  let scenarioCount = 0
  testCases.forEach(testCase => {
    // Only generate scenario if test case has steps
    if (testCase.steps && testCase.steps.length > 0) {
      // Generate Gherkin steps from test case steps
      const gherkinSteps = generateGherkinStepsFromTestCase(testCase.steps)

      // Only add scenario if there are actual gherkin steps
      if (gherkinSteps.length > 0) {
        if (scenarioCount > 0) {
          lines.push('') // Add blank line between scenarios
        }

        lines.push(`  Scenario: [${testCase.title}] ${testCase.description}`)

        gherkinSteps.forEach(step => {
          lines.push(`    ${step}`)
        })

        scenarioCount++
      }
    }
  })

  return lines.join('\n') + '\n'
}

/**
 * Generates Gherkin steps from test case steps using the same logic as the frontend
 */
function generateGherkinStepsFromTestCase(
  steps: Array<{
    gherkinStep: string
    order: number
  }>,
): string[] {
  if (!steps || steps.length === 0) {
    return []
  }

  // Sort steps by order
  const sortedSteps = steps.sort((a, b) => a.order - b.order)

  let hasThenInPrevious = false
  let hasWhenInPrevious = false

  return sortedSteps.map((step, index) => {
    const gherkinStep = step.gherkinStep?.trim() || ''
    const firstWord = gherkinStep.split(' ')[0].toLowerCase()
    const hasGherkinKeyword = ['given', 'when', 'then'].includes(firstWord)
    const stepWithoutKeyword = hasGherkinKeyword ? gherkinStep.split(' ').slice(1).join(' ') : gherkinStep

    // First step always starts with Given
    if (index === 0) {
      return `Given ${stepWithoutKeyword}`
    }

    // Check if this step should be a Then statement
    const isThenStatement =
      firstWord === 'then' ||
      stepWithoutKeyword.toLowerCase().startsWith('should') ||
      stepWithoutKeyword.toLowerCase().startsWith('must') ||
      stepWithoutKeyword.toLowerCase().startsWith('will')

    // If we haven't seen a Then yet
    if (!hasThenInPrevious) {
      // If this is a Then statement
      if (isThenStatement) {
        hasThenInPrevious = true
        return `Then ${stepWithoutKeyword}`
      }

      // If we haven't seen a When yet, use When
      if (!hasWhenInPrevious) {
        hasWhenInPrevious = true
        return `When ${stepWithoutKeyword}`
      }
      // After When, use And
      return `And ${stepWithoutKeyword}`
    }

    // After Then
    if (isThenStatement) {
      // If it's another Then statement, use And
      return `And ${stepWithoutKeyword}`
    }
    // After Then, use When for new actions
    hasThenInPrevious = false
    hasWhenInPrevious = true
    return `When ${stepWithoutKeyword}`
  })
}

/**
 * Deletes a feature file for a test suite
 * @param testSuiteId - The ID of the test suite
 * @returns Promise<boolean> - True if file was deleted, false if file didn't exist
 */
export async function deleteFeatureFile(testSuiteId: string): Promise<boolean> {
  try {
    // Fetch test suite and all modules to build the correct path
    const [testSuite, allModules] = await Promise.all([
      prisma.testSuite.findUnique({
        where: { id: testSuiteId },
        include: {
          module: true,
        },
      }),
      prisma.module.findMany(),
    ])

    if (!testSuite) {
      console.warn(`Test suite with ID ${testSuiteId} not found for feature file deletion`)
      return false
    }

    // Build the module path for directory structure
    const modulePath = buildModulePath(allModules, testSuite.module)
    const safeFileName = generateSafeFileName(testSuite.name)

    const featuresBaseDir = join(process.cwd(), 'src', 'tests', 'features')
    const moduleDir = join(featuresBaseDir, modulePath.substring(1)) // Remove leading slash
    const featureFilePath = join(moduleDir, `${safeFileName}.feature`)

    try {
      await fs.unlink(featureFilePath)
      console.log(`Feature file deleted: ${featureFilePath}`)
      return true
    } catch (error: unknown) {
      if (error && typeof error === 'object' && 'code' in error && error.code === 'ENOENT') {
        console.warn(`Feature file not found for deletion: ${featureFilePath}`)
        return false
      }
      throw error
    }
  } catch (error) {
    console.error('Error deleting feature file:', error)
    throw error
  }
}

/**
 * Regenerates all feature files from the current database state
 * This is useful after merging changes or database migrations to ensure sync
 * @returns Promise<string[]> - Array of generated feature file paths
 */
export async function regenerateAllFeatureFiles(): Promise<string[]> {
  try {
    console.log('Starting regeneration of all feature files...')

    // Clear existing feature files directory
    const featuresBaseDir = join(process.cwd(), 'src', 'tests', 'features')
    try {
      await fs.rm(featuresBaseDir, { recursive: true, force: true })
    } catch (error) {
      console.warn('Could not clear features directory:', error)
    }

    // Fetch all test suites from database
    const testSuites = await prisma.testSuite.findMany({
      include: {
        testCases: {
          include: {
            steps: {
              include: {
                parameters: true,
              },
              orderBy: {
                order: 'asc',
              },
            },
          },
        },
        module: true,
      },
    })

    // Fetch all modules for path building
    const allModules = await prisma.module.findMany()

    const generatedFiles: string[] = []

    // Generate feature file for each test suite
    for (const testSuite of testSuites) {
      try {
        const modulePath = buildModulePath(allModules, testSuite.module)
        const featureContent = generateFeatureContent(testSuite.description || testSuite.name, testSuite.testCases)

        // Create the features directory with module path
        const moduleDir = join(featuresBaseDir, modulePath.substring(1)) // Remove leading slash
        await fs.mkdir(moduleDir, { recursive: true })

        // Generate filename and write file
        const safeFileName = generateSafeFileName(testSuite.name)
        const featureFilePath = join(moduleDir, `${safeFileName}.feature`)

        await fs.writeFile(featureFilePath, featureContent, 'utf8')
        generatedFiles.push(featureFilePath)

        console.log(`Generated: ${featureFilePath}`)
      } catch (error) {
        console.error(`Error generating feature file for test suite ${testSuite.name}:`, error)
      }
    }

    console.log(`Regeneration complete. Generated ${generatedFiles.length} feature files.`)
    return generatedFiles
  } catch (error) {
    console.error('Error during feature files regeneration:', error)
    throw error
  }
}

/**
 * Generates a safe filename from test suite name
 */
function generateSafeFileName(testSuiteName: string): string {
  // Convert to lowercase and replace spaces and special characters with hyphens
  return testSuiteName
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
    .replace(/-+/g, '-') // Replace multiple consecutive hyphens with single hyphen
}
